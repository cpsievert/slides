{
    "contents" : "\\documentclass[10pt,journal,compsoc]{IEEEtran}\n%\\documentclass[review,journal]{vgtc}         % review (journal style)\n%\\documentclass[widereview]{vgtc}             % wide-spaced review\n%\\documentclass[journal]{vgtc}                % final (journal style)\n%\\documentclass[preprint,journal]{vgtc}       % preprint (journal style)\n%\\documentclass[electronic,journal]{vgtc}     % electronic version, journal\n%\\usepackage{color}\n\\usepackage{stmaryrd}\n\\usepackage{stfloats}\n%% Uncomment one of the lines above depending on where your paper is\n%% in the conference process. ``review'' and ``widereview'' are for review\n%% submission, ``preprint'' is for pre-publication, and the final version\n%% doesn't use a specific qualifier. Further, ``electronic'' includes\n%% hyperreferences for more convenient online viewing.\n\n%% Please use one of the ``review'' options in combination with the\n%% assigned online id (see below) ONLY if your paper uses a double blind\n%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT\n%% in the past.\n\n%% Please note that the use of figures other than the optional teaser is not permitted on the first page\n%% of the journal version.  Figures should begin on the second page and be\n%% in CMYK or Grey scale format, otherwise, colour shifting may occur\n%% during the printing process.  Papers submitted with figures other than the optional teaser on the\n%% first page will be refused.\n\n%% These three lines bring in essential packages: ``mathptmx'' for Type 1\n%% typefaces, ``graphicx'' for inclusion of EPS figures. and ``times''\n%% for proper handling of the times font family.\n\\usepackage{natbib}\n\\usepackage{mathptmx}\n\\usepackage{graphicx}\n\\usepackage{times}\n%% We encourage the use of mathptmx for consistent usage of times font\n%% throughout the proceedings. However, if you encounter conflicts\n%% with other math-related packages, you may want to disable it.\n\n%% This turns references into clickable hyperlinks.\n\\usepackage[bookmarks,backref=true,linkcolor=black]{hyperref} %,colorlinks\n\\hypersetup{\n  pdfauthor = {},\n  pdftitle = {},\n  pdfsubject = {},\n  pdfkeywords = {},\n  colorlinks=true,\n  linkcolor= black,\n  citecolor= black,\n  pageanchor=true,\n  urlcolor = black,\n  plainpages = false,\n  linktocpage\n}\n\n\\newcommand{\\bitly}[1]{\\href{http://bit.ly/#1}{\\texttt{#1}}}\n\n\\begin{document}\n\n%% If you are submitting a paper to a conference for review with a double\n%% blind reviewing process, please replace the value ``0'' below with your\n%% OnlineID. Otherwise, you may safely leave it at ``0''.\n\n%% declare the category of your paper, only shown in review mode\n\n%% allow for this line if you want the electronic option to work properly\n\n%% In preprint mode you may define your own headline.\n%\\preprinttext{To appear in an IEEE VGTC sponsored conference.}\n\n%% Paper title.\n\n\\title{Animint: a Grammar for Interactive Animations}\n\n%% This is how authors are specified in the journal style\n\n%% indicate IEEE Member or Student Member in form indicated below\n\\author{Toby Dylan Hocking, \n  Carson Sievert, \n  Susan VanderPlas%\n\\IEEEcompsocitemizethanks{\\IEEEcompsocthanksitem\n    Toby Dylan Hocking \n    is with the McGill University department of Human Genetics,\n    Susan VanderPlas and Carson Sievert \n    are with Iowa State University department of Statistics.\n\\protect\\\\\n% note need leading \\protect in front of \\\\ to get a newline within \\thanks as\n% \\\\ is fragile and will error, could use \\hfil\\break instead.\nE-mail: toby.hocking@mail.mcgill.ca.}% <-this % stops a space\n\\thanks{Manuscript received April 19, 2005; revised September 17, 2014.}}\n\n% note the % following the last \\IEEEmembership and also \\thanks - \n% these prevent an unwanted space from occurring between the last author name\n% and the end of the author line. i.e., if you had this:\n% \n% \\author{....lastname \\thanks{...} \\thanks{...} }\n%                     ^------------^------------^----Do not want these spaces!\n%\n% a space would be appended to the last name and could cause every name on that\n% line to be shifted left slightly. This is one of those \"LaTeX things\". For\n% instance, \"\\textbf{A} \\textbf{B}\" will typeset as \"A B\" not \"AB\". To get\n% \"AB\" then you have to do: \"\\textbf{A}\\textbf{B}\"\n% \\thanks is no different in this regard, so shield the last } of each \\thanks\n% that ends a line with a % and do not let a space in before the next \\thanks.\n% Spaces after \\IEEEmembership other than the last one are OK (and needed) as\n% you are supposed to have spaces between the names. For what it is worth,\n% this is a minor point as most people would not even notice if the said evil\n% space somehow managed to creep in.\n\n\n\n% The paper headers\n\\markboth{Journal of \\LaTeX\\ Class Files,~Vol.~13, No.~9, September~2014}%\n{Shell \\MakeLowercase{\\textit{et al.}}: Bare Advanced Demo of IEEEtran.cls for Journals}\n% The only time the second header will appear is for the odd numbered pages\n% after the title page when using the twoside option.\n% \n% *** Note that you probably will NOT want to include the author's ***\n% *** name in the headers of peer review papers.                   ***\n% You can use \\ifCLASSOPTIONpeerreview for conditional compilation here if\n% you desire.\n\n\n\n% The publisher's ID mark at the bottom of the page is less important with\n% Computer Society journal papers as those publications place the marks\n% outside of the main text columns and, therefore, unlike regular IEEE\n% journals, the available text space is not reduced by their presence.\n% If you want to put a publisher's ID mark on the page you can do it like\n% this:\n%\\IEEEpubid{0000--0000/00\\$00.00~\\copyright~2014 IEEE}\n% or like this to get the Computer Society new two part style.\n%\\IEEEpubid{\\makebox[\\columnwidth]{\\hfill 0000--0000/00/\\$00.00~\\copyright~2014 IEEE}%\n%\\hspace{\\columnsep}\\makebox[\\columnwidth]{Published by the IEEE Computer Society\\hfill}}\n% Remember, if you use this you must call \\IEEEpubidadjcol in the second\n% column for its text to clear the IEEEpubid mark (Computer Society journal\n% papers don't need this extra clearance.)\n\n\n\n% use for special paper notices\n%\\IEEEspecialpapernotice{(Invited Paper)}\n\n\n\n% for Computer Society papers, we must declare the abstract and index terms\n% PRIOR to the title within the \\IEEEtitleabstractindextext IEEEtran\n% command as these need to go into the title area created by \\maketitle.\n% As a general rule, do not put math, special symbols or citations\n% in the abstract or keywords.\n\\IEEEtitleabstractindextext{%\n\\begin{abstract}\n  Animint is a new domain-specific language (DSL) for linked,\n  interactive, animated plots. It builds on top of previous work on\n  the grammar of graphics (ggplot2 in R) and interactive visualization\n  using web standards (D3 in JavaScript). In other data visualization\n  systems, interactive animations are difficult to accomplish, since\n  they must be defined in terms of low-level operations and sometimes\n  100s of lines of code. In contrast, Animint's high-level DSL can be\n  used to produce a wide variety of complex interactive visualizations\n  with only 10s of lines of code. It works by adding 2 new aesthetics\n  to the grammar of graphics: \\texttt{clickSelects}, which allows users to\n  select elements of the plot, and \\texttt{showSelected}, which displays\n  only elements corresponding to the current selection. After using\n  the declarative Animint DSL to define an interactive animation in R\n  code, it is first compiled and then rendered in a web browser using\n  D3. We discuss the design of Animint, then compare to related\n  libraries, and show several example visualizations of\n  high-dimensional time series data. A free/open-source implementation\n  of Animint is available at \\url{https://github.com/tdhock/animint}.\n\\end{abstract}\n\n% Note that keywords are not normally used for peerreview papers.\n\\begin{IEEEkeywords}\nInformation visualization, user interfaces, toolkits, 2D\n  graphics, interactive, animation\n\\end{IEEEkeywords}\n\n\n% make the title area\n\n\n% To allow for easy dual compilation without having to reenter the\n% abstract/keywords data, the \\IEEEtitleabstractindextext text will\n% not be used in maketitle, but will appear (i.e., to be \"transported\")\n% here as \\IEEEdisplaynontitleabstractindextext when compsoc mode\n% is not selected <OR> if conference mode is selected - because compsoc\n% conference papers position the abstract like regular (non-compsoc)\n% papers do!\n\\IEEEdisplaynontitleabstractindextext\n% \\IEEEdisplaynontitleabstractindextext has no effect when using\n% compsoc under a non-conference mode.\n\n\n% For peer review papers, you can put extra information on the cover\n% page as needed:\n% \\ifCLASSOPTIONpeerreview\n% \\begin{center} \\bfseries EDICS Category: 3-BBND \\end{center}\n% \\fi\n%\n% For peerreview papers, this IEEEtran command inserts a page break and\n% creates the second title. It will be ignored for other modes.\n\\IEEEpeerreviewmaketitle\n\n}\n\n%% Keywords that describe your work. Will show as 'Index Terms' in journal\n%% please capitalize first letter and insert punctuation after last keyword\n\n%% ACM Computing Classification System (CCS). \n%% See <http://www.acm.org/class/1998/> for details.\n%% The ``\\CCScat'' command takes four arguments.\n\n\n\n\n\n%% Uncomment below to disable the manuscript note\n%\\renewcommand{\\manuscriptnotetxt}{}\n\n%% Copyright space is enabled by default as required by guidelines.\n%% It is disabled by the 'review' option or via the following command:\n% \\nocopyrightspace\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n%% The ``\\maketitle'' command must be the first command after the\n%% ``\\begin{document}'' command. It prepares and prints the title block.\n\n\n\\maketitle\n\n%% Uncomment below to include a teaser figure.\n\\begin{figure*}[b!]\n  \\centering\n  \\includegraphics[width=\\textwidth]{figure-1}\n  \\caption{This interactive animation of World Bank data was designed\n    with only 20 lines of Animint code (\\url{http://bit.ly/worldBank}).\n    \\textbf{Top text}: Five geometric elements span two linked plots:\n    clicking a \\texttt{clickSelects} element changes the currently\n    selected year or country, and updates the corresponding\n    \\texttt{showSelected} elements.  \\textbf{Left plot}: a multiple\n    time series from 1960 to 2012 of the life expectancy of 205\n    countries, with bold lines showing the selected countries and a\n    vertical grey tallrect showing the selected year.  \\textbf{Right\n      plot}: a scatterplot of life expectancy versus fertility rate of\n    all countries. The two text elements show the current selection:\n    year=1975 and country=$\\{\\textrm{United States},\n    \\textrm{Vietnam}\\}$}\n  \\label{fig:1}\n\\end{figure*}\n\n\\section{Introduction}\n\nInteractive, animated data visualization is a useful tool for\nobtaining an intuitive understanding of patterns in multivariate data\nsets. In this paper, we introduce Animint, a system for designing\nlinked, interactive, animated data visualizations. To demonstrate its\ndesign, we begin with an illustrative example.\n\nConsider the World Bank data set, which consists of several economic\nvariables measured for 205 countries from 1960 to 2012\n\\citep{WorldBank}. Figure~1 shows six variables from this data set:\nyear, country, life expectancy, fertility rate, region, and\npopulation. In the static PDF version of this figure, the year 1975\nand the countries United States and Vietnam are selected, but readers\nare encouraged to view and select other countries using a web browser\n(\\url{http://bit.ly/worldBank}).\n%% TODO: Let's update this example and facet the bar chart by region\nIn the interactive version, the selected value of the year variable is\nautomatically incremented every few seconds, using animation to\nvisualize yearly changes in the relationship between life expectancy and\nfertility rate. This is just one example in\nwhich interaction and animation help to reveal patterns in a\nhigh-dimensional data set. The Animint system provides a\ndomain-specific language (DSL) that simplifies the creation of such\ninteractive and animated data visualizations.\n\n% I wanted to just emphasize the difference between an Animint\n% interactive graphic and a static graphic. In static graphics the\n% designer chooses both the aes mappings and the subset of data to\n% show. However in Animint the designer only chooses the aes mappings\n% and then the user is free to choose the selection. Do you have some\n% idea how to get that message across?\n\n%% Carson: There are only *two* roles in *creating* visualizations\nIn general, there are three influential roles in the\nconsumption of an Animint visualization: the developer, who implements\nthe Animint library; the designer, who uses the Animint library to\ndefine a visualization; and the user, who selects data subsets to view in a\nweb browser. The main goal of Animint is to provide an expressive\nlanguage for designers, while allowing users the freedom to interact\nwith the plot to selectively view data subsets of interest. The\ndesigner specifies data sets and maps variables to interactive visual\nelements using the Animint DSL, then uses the Animint library to\ncompile and save an interactive animation. The user writes no code,\nbut can view and interact with an Animint visualization by clicking\nScalable Vector Graphics (SVG) elements in a web browser. The Animint \nlibrary developer is responsible for the plot rendering details,\nwhich allows the others to focus on designing and consuming visualizations.\n\n%interested in re-implementing the Animint\n%system, we discuss details of its implementation in\n%Section~\\ref{sec:implementation}.\n\nThe Animint DSL is for visualizations which are both interactive and\nanimated. For the purposes of this paper, we define ``interactive'' to\nmean that graphical elements such as data points may be clicked to\nupdate the data that is shown in related plots. This is closely\nrelated to the concept of ``direct manipulation,'' which was\nintroduced by \\citet{shneiderman82} and later applied to statistical\ndata visualization \\citep{Hutchins:1985, brushing-scatterplots,\n  cleveland}. Our definition of an ``animated'' visualization is one\nthat can be watched like a video, automatically updating over time.\n\n%% There is also a very nice discussion about Semantic and\n%% Articulatory distance which we could use. Our DSL lowers the\n%% semantic distance of the designer, and our renderer lowers the\n%% articulatory distance of the user. Mapping the time variable in a\n%% data set to the time variable in an animated plot is justified via\n%% articulatory directness. Quoting:\n\n%% Semantic distance concerns the relation of the meaning of an\n%% expression in the interface language to what the user wants to\n%% say. Two important questions about semantic distance are (1) Is it\n%% possible to say what one wants to say in this lan- guage? That is,\n%% does the language support the user's conception of the task do-\n%% main? Does it encode the concepts and distinctions in the domain in\n%% the same way that the user thinks about them? (2) Can the things\n%% ofintmest be said concisely?  Can the user say what is wanted in a\n%% straightforward fashion, or must the user construct a complicated\n%% expression to do what appears in the user's thoughts as a\n%% conceptually simple piece of work?  ... Where semantic distance has\n%% to do with the relationship between user's intentions and meanings\n%% of expressions, articulatory distance has to do with the\n%% relationship between the meanings of ex- pressions and their\n%% physical form. ...  Take the simple, commonplace activity of moving\n%% a cursor on the screen. If we do this by moving a mouse, pointing\n%% with a finger or a light pen at the screen, or otherwise mimicking\n%% the desired motion, then at the level of action execution, these\n%% interactions all exhibit articulatory directness. The meaning of\n%% the intention is cursor movement and the action is specified by\n%% means of a similar movement. One way to achieve articulatory\n%% directness at the input side is to provide an interface that\n%% permits specification of an action by mimicking it, thus supporting\n%% an articulatory similarity between the vocabulary item and its\n%% meaning. Any nonarbitrary relationship between the form of an item\n%% and its meaning can be a basis for articulatory directness. ...\n%% Articulatory directness on the output side is similar. If the user\n%% is following the changes in some variable, a moving graphical\n%% display can provide articula- tory directness. A table of numbers,\n%% although containing the same semantic in- formation, does not\n%% provide articulatory directness. Thus, the graphical display and\n%% the table of numbers might be equal in semantic directness, but\n%% unequal in articulatory directness.\n\n%% Spatial vs temporal indirection:\n\n%% These two types of activation are quite different. The activation\n%% of the scrollbar is spatial because it is caused by moving the\n%% mouse (and cursor) inside the area of the scrollbar. The activation\n%% of the rectangle creation instrument is temporal because it is\n%% caused by a former action and remains in effect until the\n%% activation of another instrument. (This is traditionally called a\n%% mode). Each type of activation has an associated cost: Spatial\n%% activation requires the instrument to be visible on the screen,\n%% taking up screen real-estate and requiring the user to point at it\n%% and potentially dividing the user's attention. Temporal activation\n%% requires an explicit action to trigger the activation, making it\n%% slower and less direct.  Interface designers often face a design\n%% trade-off between temporal and spatial multiplexing of instruments\n%% because the activation costs become significant when the user must\n%% frequently change instruments. Using extra input devices can reduce\n%% these costs. For example, the thumbwheel on Microsoft's\n%% Intellimouse is a scrolling instrument that is always active. An\n%% extreme example is an audio mixing console, which may contain\n%% several hundred potentiometers and switches, each corresponding to\n%% a single function. This permits very fast access to all functions,\n%% which is crucial for sound engineers working in real-time and\n%% cannot afford the cost of activating each function indirectly. A\n%% large design space lies between a single mouse and hundreds of\n%% potentiometers, posing design challenges to maximally exploit\n%% physical devices and reduce activation costs.\n\n\n%TODO: examples of animated and interactive, World\n%Bank and Fig 9 of \\citet{d3}.\n\nThe type of interactivity that we propose is closely related to the\nsystem described by \\citet{cleveland}. In that system, the user's\nmouse creates a single rectangular brush which either defines the\nselection (transient mode), or defines data points to add to or remove\nfrom the selection (lasting mode or erasing mode). Cleveland also\ndefines several operations on the selection, such as labeling,\ndeleting, and enhanced linking. For example, in a scatter plot matrix,\nCleveland uses enhanced linking to highlight which points are selected\nin each plot.\n\nIn Animint, the central concept of interactivity is a selection\nvariable, such as year or country in Figure~1. For each selection\nvariable, one or several values can be selected at a time,\ne.g. year=1975 and country=\\{United States, Vietnam\\}. \nLike Cleveland's system, Animint supports enhanced\nlinking to highlight the selected value(s) of each selection variable. In\ncontrast to Cleveland's single rectangular brush that selects points in\nplots of a single data table, an Animint designer may designate\nseveral selection variables in plots of several linked data tables. To\ndeclare a clickable plot element that changes the selected value of\nthe year variable, an Animint designer writes\n\\texttt{clickSelects=year}.\n%within a ggplot2 aes specification.\n\nTo achieve data-driven animations, Animint defines one other important\noperation involving selection variables: showing and hiding subsets of\ndata. For example, in the scatterplot of Figure~1 we draw a point for\neach country, and want to move and change the size of each point as\nthe selected year changes. To accomplish this, an Animint designer can\nsimply declare \\texttt{showSelected=year} which means to show only the\ndata with the selected value of year.\n\nUsing just the \\texttt{clickSelects} and \\texttt{showSelected}\nkeywords, a wide variety of interactive visualizations can be\ndefined. To make the selection automatically change over time\n(animation), an Animint designer may declare one variable as the\n\\texttt{time} variable. Since it is perceptually advantageous to have\nsmooth transitions in data-driven animations\n\\citep{animated-transitions}, an Animint designer may also declare a\n\\texttt{duration} list of selection variables which should have smooth\ntransitions.\n\nThe Animint DSL is implemented as an extension of ggplot2\n\\citep{ggplot2-book, ggplot2-paper}, which is an R implementation of\nthe grammar of graphics \\citep{wilkinson}. The ggplot2 language was\ncreated as a high-level abstraction for non-interactive\nvisualizations. One of the key strengths of ggplot2 is that it allows\na designer to declare a visualization using multiple layers of distinct \ngeometric elements, each with a clear aesthetic mapping from data \nvariables to geometric properties. The Animint DSL extends ggplot2 by adding\n\\texttt{clickSelects} and \\texttt{showSelected} aesthetics.\n\n\\begin{figure*}[b!]\n  \\centering\n  \\begin{tabular}{ccc}\n  \\begin{minipage}{2.5in}\n    \\centering\n    \\textbf{D3 (Javascript code)}\n    \\small\n\\begin{verbatim}\nsvg.selectAll(\"circle\")\n  .data(one_year)\n  .enter().append(\"circle\")\n.attr(\"cx\", function(d){\n  return x_scale(d.fertility_rate);\n}).attr(\"cy\", function(d){\n  return y_scale(d.life_expectancy);\n}).attr(\"r\", function(d){\n  return size_scale(d.population);\n}.style(\"fill\", function(d){\n  return color_scale(d.region);\n})\n\\end{verbatim}\n  \\end{minipage}\n  &\n  \\begin{minipage}{2.6in}\n    \\centering\n    \\textbf{Vega (JSON file)}\n    \\small\n\\begin{verbatim}\n{ \"marks\": [{\n  \"type\":\"symbol\",\n  \"from\": {\"data\":\"this_year\"},\n  \"properties\":{ \"enter\":{\n    \"x\": {\"field\": \"fertility_rate\"},\n    \"y\": {\"field\": \"life_expectancy\"},\n    \"size\": {\"field\": \"population\"},\n    \"fill\": {\"field\": \"region\"}\n}}}]}\n\\end{verbatim}\n  \\end{minipage}\n  &\n  \\begin{minipage}{2in}\n    \\centering\n    \\textbf{Animint (R code)}\n    \\small\n\\begin{verbatim}\ngeom_point(aes(\n  x=fertility.rate,\n  y=life.expectancy,\n  color=region,\n  size=population,\n\\end{verbatim}\n    {\\color{red}\n\\begin{verbatim}\n  clickSelects=country,\n  showSelected=year),\n\\end{verbatim}\n      }\n\\begin{verbatim}\n  data=WorldBank)\n\\end{verbatim}\n    \\end{minipage}\n  \\end{tabular}\n  \\caption{Comparison of code used to define points on a scatterplot.\n    Note that the Animint code is shorter and simpler than the D3 and\n    Vega code. Animint and Vega provide nice defaults for plot elements such \n    as the axes and labels, but these elements still need to be expressed \n    in the D3 code. Also, Animint implements the proposed\n    \\texttt{clickSelects} and \\texttt{showSelected} aesthetics (red),\n    but D3 and Vega do not.}\n  \\label{fig:code}\n\\end{figure*}\n\n%% Carson: This seems like an opportunity to compare to Vega.\n%% Animint is similar in the respect that the renderer takes \n%% a JSON object as it's 'input', but it doesn't have the equivalent\n%% of Animint's compiler.\nThe Animint library includes a compiler that converts a list of\nggplots to an interactive web visualization rendered using the\nData-Driven Documents (D3) library for JavaScript \\citep{d3}. One of\nthe main reasons for the success and popularity of D3 is that it\nallows visualizations to be specified using the terminology of the\nDocument Object Model (DOM), which makes learning D3 easy for web\ndesigners. Animint's DSL abandons the DOM standard and sacrifices some\nof the flexibility of D3, but it \n%reduces the cognitive effort required to create\nsimplifies creation of visualizations in which users can quickly show/hide \nvarious subsets of data (especially for those familiar with ggplot2).\n\nFinally, another key strength of ggplot2 and D3 for visualization\ndesign are the libraries' declarative syntax. \\citet{declarative}\nproposed a declarative syntax for animated transitions, and studied\nthe benefits of declarative languages for data visualization. Animint\nis another declarative DSL, but defined at a higher level of\nabstraction than D3. It enables designers to focus on data\nvisualization, while the Animint library developers can work on\nimproving the lower-level rendering details.\n\nThe rest of this paper is organized as follows: we discuss related work in\nSection~2, and the design of the Animint system in Section~3. Then we\nperform a detailed comparison with other R packages in Section~4, and\nshow some example applications of Animint in Section~5. Finally, we\nshare some user feedback in Section~6 and then discuss future work in\nSection~7.\n\n%% \\section{Introduction} %for journal use above \\firstsection{..} instead\n\n\\section{Related Work}\n\nIn this section we offer a comparison between Animint and several\nrelated systems, focusing on libraries with free/open-source software\nimplementations in JavaScript and R. \n%% In short, Animint supports many \n%% features available in low-level implementations that are not available \n%% for higher-level efforts without sacrificing expressiveness.\n\n%% In short, Animint is the first system to propose the clickSelects and\n%% showSelected keywords, which simplify the design of a large\n\n\\subsection{D3 and other JavaScript libraries}\n\nAnimint uses \\href{http://d3js.org/}{D3} to render interactive\nanimations in a web browser \\citep{d3}. D3 uses a lower level of\nabstraction than Animint, so it is able to express a wider variety of\nvisualizations. However, Animint can be used to more succinctly\ndeclare certain types of data visualizations. For example,\nFigure~\\ref{fig:code} shows some Animint and D3 code required to\ndefine the scatterplot in the WorldBank visualization. D3 uses a\ndata-bind operation followed by several accessor functions, whereas\nAnimint uses a shorter syntax involving an \\texttt{aes} mapping\nof data variables to geometric attributes. Importantly, Animint is\nable to express interactivity using the simple \\texttt{clickSelects}\nand \\texttt{showSelected} keywords, whereas D3 would require much more\ncode involving handler functions for mouse click events.\n\n%% Carson: I think this paragraph needs to be a bit more careful/specific\n%% with it's claims. For example, ggvis now has linked brushing,\n%% Winston Chang presented it at useR 2014 -- \n%% https://twitter.com/winston_chang/status/484039769265938432\nThere are many other libraries which can generate web plots with\nlimited interactivity, but are currently unable to produce interactive\nanimations. For example, the rCharts R package is a wrapper around\nseveral JavaScript libraries \\citep{rcharts}. In contrast to Animint,\nrCharts currently does not include heuristics for describing interactions between\nmultiple plots. Thus, rCharts can easily produce graphics with simple interactive\nfeatures (such as tooltips), but it can not produce multi-plot \ninteractive animations as easily as Animint.\n\nFinally, Dimensional Charting (DC) is another JavaScript library which\ncan produce interactive visualizations consisting of several linked\nplots \\citep{dc}. Like Animint, DC builds on top of D3. Unlike\nAnimint, DC does not use the grammar of graphics, so data\nvisualization designers are limited to plot types that are pre-defined\nby the DC library developers.\n\n\\subsection{Animated graphics libraries}\n\nOne way to achieve animation in an iterative programming syntax is by\nusing a for statement to loop over the time variable. This is the main\nidea of the \\href{http://yihui.name/animation/}{animation} package\n\\citep{animation}. The main difference between this system\nand Animint is that the only interaction possible with\nanimation is rewinding and fast-forwarding through the\nanimation frames. \n\nAnother way to produce an animated scatterplot of the World Bank data\nis by using a Google motion chart, available in R through the\ngoogleVis package \\citep{googleVis}. The main limitation of this\nsystem is that it can only produce a few pre-defined plot types, only one\nof which can be viewed at any time.\n\n\\subsection{Libraries based on the grammar of graphics}  \n\nIn this section we discuss the differences between Animint and several\nother high-level DSLs for data visualization based on the grammar of\ngraphics \\citep{wilkinson}.\n\n\\begin{figure*}[p]\n  \\centering\n  \\includegraphics[width=\\textwidth]{figure-tornado}\n  \\caption{Interactive animation of tornadoes recorded from 1950 to\n    2012 in the United States (\\url{http://bit.ly/1hWvYo0}). \\textbf{Left}:\n    map of the lower 48 United States with tornado paths in 1982. The\n    text shows the selected year, and clicking the map changes the\n    selected state, currently Texas. \\textbf{Right}: time series of\n    tornado counts in Texas. Clicking a bar changes the selected year,\n    and the text shows selected state and the number of tornadoes\n    recorded there in that year (119 tornadoes in Texas in 1982).}\n  \\label{fig:tornado}\n\\end{figure*}\n\n\\begin{figure*}[p]\n  \\centering\n  \\includegraphics[width=\\textwidth]{figure-climate}\n  \\caption{Visualization containing 6 linked, interactive, animated\n    plots of Central American climate data\n    (\\url{http://bit.ly/QcUrhn}). \\textbf{Top}: for the selected time\n    (December 1997), maps displaying the spatial distribution of two\n    temperature variables, and a scatterplot of these two\n    variables. The selected region is displayed with a black outline,\n    and can be changed by clicking a rect on the map or a point on the\n    scatterplot. \\textbf{Bottom}: time series of the two temperature\n    variables with the selected region shown in violet, and a\n    scatterplot of all times for that region. The selected time can be\n    changed by clicking a background tallrect on a time series or a\n    point on the scatterplot. The selected region can be changed by\n    clicking a line on a time series.}\n  \\label{fig:climate}\n\\end{figure*}\n\nAnimint extends the declarative DSL of\n\\href{http://ggplot2.org/}{ggplot2} \\citep{ggplot2-book,\n  ggplot2-paper}. Strictly speaking, ggplot2 is for non-interactive\nand non-animated visualizations. In this paper, we propose the\n\\texttt{clickSelects} and \\texttt{showSelected} aesthetics for\nggplot2, which extend it to accommodate interactive, animated\ngraphics. \n\nAnother R package that uses the grammar of graphics to define\ninteractive graphics is \\href{http://ggvis.rstudio.com/}{ggvis}\n\\citep{ggvis}. Unlike Animint, ggvis does not directly extend ggplot2,\nbut provides a new implementation of some of the same ideas about the\ngrammar of graphics. The main difference is that ggvis relies on shiny's\nreactive framework to acheive interactivity. That is, in order to be interactive, ggvis requires a web server that runs R and shiny. Animint does not require any special web server software since it uses static files and client-side JavaScript. If Animint users are familiar with shiny, they may leverage it's reactive framework to acheive interactivity that is not possible with \\texttt{clickSelects} and \\texttt{showSelected} alone. This simple example demonstrates that one can incorporate widgets to change x/y/color variables without writing one line of HTML/JavaScript \\url{http://bit.ly/animint-rmarkdown}.\n\n%% Carson: I might be persuaded, but I don't think the argument below will \n%% stand the test of time. ggvis is rapidly evolving and already \n%% has decent support for 'direct manipulation' and 'linked plots':\n%% shiny::runGitHub(repo = \"ggvis\", username = \"rstudio\", subdir = \"demo/apps/brush-linked\")\n%% I'll see if I can come up with a ggvis example that is closer to animint's\n%% than Susan's current example -- https://srvanderplas.shinyapps.io/ggvis-animint/\n\n% The two packages also have different interactive\n% features: ggvis uses sliders, checkboxes, and other HTML form\n% elements, whereas Animint users can directly click the SVG elements\n% that are used to visualize the data. For example, in a ggvis of the\n% WorldBank data, it is natural to use a slider to select the displayed\n% year. In contrast, in Animint we used a multiple time series plot\n% where the year can be selected by directly clicking the data values on\n% the plot (Figure~1). The Animint plot is thus easier for the user\n% since it has more articulatory directness \\citep{Hutchins:1985}, and\n% less spatial offset \\citep{instrumental-interaction}.\n\n%\\paragraph{Vega}\nLike Animint, \\href{http://trifacta.github.io/vega/}{Vega} is a\ndeclarative DSL that builds on top of D3 \\citep{vega}. Vega is unable\nto express all plots that can be made using pure D3, but provides a\nJSON file format capable of defining many common plots\n(Figure~\\ref{fig:code}). As discussed in Section~\\ref{sec:design},\nAnimint also internally uses a JSON file to store meta-data about an\ninteractive animation. The main difference \nis that Vega does not support interactions and animation that show and hide\ndata subsets across multiple linked plots. Finally,\n\\citet{2014-reactive-vega} proposed some declarative Vega\nextensions ``critical for developing interactive data\nvisualizations.''  Those extensions are defined at a lower level of\nabstraction than the \\texttt{clickSelects} and \\texttt{showSelected}\nkeywords of Animint.\n\nImplementations of the grammar of graphics system of\n\\citet{wilkinson} exist as the Visualization Markup Language (ViZml)\nand the Graphics Production Language (GPL) in IBM SPSS Statistics\nsoftware, but do not support interactive animations.\n\n\\subsection{Other systems with interactive selection} \n\nThere are many different methods for interactively specifying a set of\nselected data points \\citep{scented-widgets, heer2008generalized}. A\ncommon interaction involves a rectangular brush that can select\nseveral data points in a single data table \\citep{cleveland,\n  brushing-scatterplots}, and highlights the selected data points\nacross several plots. Importantly, Animint supports selecting and\nhighlighting several different variables (e.g. year and\ncountry), each of which supports either single or multiple\nselection. However, the current implementation of Animint does not\nsupport selection using a rectangular brush (users must click each\ndata point to add/remove it from the set of selected values).\n\nAnother system with interactive facilities similar to Animint is\n \\citet{tableau}. Like Animint, it has a declarative\ninterface that can acheive interactive animations. \nTableau is built on top of VizQL, a visual query language\nwhich took influence from Polaris \\citep{polaris}. \nVisual query languages automatically and dynamically \nexecute (and, in some cases, cache) database queries \nrequired to render various properties of the user \ndefined visualization. \n\nTableau's visual query approach is quite nice for many cases, but\nit does not easily acheive the same level of flexibility \nthat ggplot2's layered grammar of graphics provides.\nThat is, ggplot2 allows for a different data table \nto be mapped to a different layer of geometries/marks, \nwhile Tableau requires each layer to be a function of a \nsingle query result. This proves to be an important\ndifference in the selection model as well since the ability to\nselect and target different layers of marks/geometries. \nIn context of the World Bank visualization, if we page through\nthe different years, it is not possible target only the rectangles\n\\url{http://bit.ly/worldBank-tableau}.\n\nAnother fundamental limitation to a visual query language is the\nrestriction to database primitives. For instance, suppose \nwe want to visualize the residuals of different models \nfit to different subsets of the data. This would require us \nto precompute the residuals using a different language \n(such as R) and write tables back to the database. This can\nlead to an inefficient workflow if we aren't interested in \nkeeping certain models/tables. Starting with version 8.1,\nTableau does offer R integration, but the types of objects \nthat can be transferred are limited and it removes the REPL\nenvironment that R users enjoy.\n\n\\section{The Animint system}\n\\label{sec:design}\n\nIn this section we explain the main ideas of how Animint can be used\nfor interactive animations. We first explain the DSL that a designer\nuses to specify an interactive plot, then explain the user interface\nfor selecting data subsets. Finally, we discuss some implementation\ndetails of the compiler and renderer, which only the Animint\ndevelopers need to be concerned about.\n\n\\subsection{The Animint grammar for interactive animations}\n\n<<opts, echo=FALSE, message=FALSE, cache=FALSE>>=\nlibrary(animint)\ndata(WorldBank)\nwrite.csv(WorldBank, \"WorldBank.csv\")\nopts_chunk$set(tidy=FALSE, eval=FALSE)\nopts_knit$set(out.format=\"latex\")\nknit_theme$set(\"edit-matlab\")\n@ \n\nThe main idea of Animint is that a large class of interactive plots\ncan be specified using just two interactive keywords:\n\\texttt{clickSelects} and \\texttt{showSelected}. For example, after\nclicking a \\texttt{clickSelects=year} element, the plot\nis updated to show only the \\texttt{showSelected=year} elements\ncorresponding to the selected year. These two simple keywords\nform the basis of the Animint DSL which makes it easy for designers\nto translate ideas into code and then visualizations.\n\nThe first step in the design of any data visualization\nis usually to make a sketch\nof the desired interactive plot on paper or a whiteboard. \nIn any plot a designer would sketch\nthe axes, legends, a few geometric elements, and note which variables\nwill be shown in the linked plots. An Animint designer needs only add\nthe \\texttt{clickSelects} and\n\\mbox{showSelected} mappings for each geometric element, as shown in\nFigures~1, 3, and 4. These notes can be directly translated to\nggplot2 aesthetics in R code, as explained below.\n\n\\begin{figure*}[b!]\n  \\centering\n  \\includegraphics[width=\\textwidth]{figure-chip-seq}\n  \\caption{Visualization with 4 selection variables used to navigate\n    through 1,292,464 rows of data in 5 linked interactive plots \n    %of a L1-regularized logistic regression model of ChIP-seq data\n    (\\url{http://bit.ly/1pVZZaS}). The bottom plot shows a\n    facets plot with aligned x axes, used to emphasize that the\n    blue probability function is defined at the same positions as the\n    black signals below. It also contains an href tag (web link), which opens a\n    new genome browser web page zoomed to the same region as the\n    selected data.}\n  \\label{fig:ChIPseq}\n\\end{figure*}\n\nAnimint implements the \\texttt{clickSelects} and \\texttt{showSelected}\ninteractive keywords as aesthetics in ggplot2. An aesthetic is a\ndeclarative mapping from a data variable to a visual property of a\ngeometric plot element. Some standard ggplot2 aesthetics are\n\\begin{description}\n\\item[x] horizontal position,\n\\item[y] vertical position,\n\\item[color] color or fill,\n\\item[size] point or line thickness.\n\\end{description}\n\nFor example, consider the following R code which defines the points in the\nWorld Bank data scatterplot on the right of Figure~1:\n\n<<countryPoints>>=\ncountryPoints <- geom_point(\n    aes(x=fertility.rate, y=life.expectancy, \n        color=region, size=population,\n        clickSelects=country, \n        showSelected=year),\n    data=WorldBank)\n@\n\nThe code defines a \\verb+geom_point+, which means to create a point\nfor every row in the \\texttt{WorldBank} data table. The visual\ncharacteristics of each point are defined by the values of the\ncorresponding data: the (x,y) position encodes fertility rate and life\nexpectancy, point color encodes the region, and point size encodes the\npopulation. Note that scales are automatically constructed for the x\nand y axes, and legends are automatically constructed for color and\nsize. The interactivity is also defined as a simple variable mapping:\n\\texttt{clickSelects=country} means that clicking a point changes the\nselected country, and \\texttt{showSelected=year} means to only plot\nthe points for the selected year.\n\nIn order to remind the plot user which subset of data are selected, we\nwill draw a text label with the selected year and country. First, we\ncreate the year labels using\n\n<<yearText-geom, tidy=FALSE>>=\nyearText <- geom_text(\n  aes(label=sprintf(\"year = %d\", year), \n      showSelected=year),\n  x=5, y=80, \n  data=years)\n@ \n\nNote that \\texttt{data=years} specifies another data table, with 1 row\nfor each year. Animint does not require that linked plots originate\nfrom the same data table; the \\texttt{clickSelects} and\n\\texttt{showSelected} aesthetics will work as long as the different\ndata tables have common variable names (e.g. the \\texttt{year}\nvariable is present in both \\texttt{WorldBank} and \\texttt{years}).\nThe \\texttt{label} aesthetic is used to define the text from the year\nvariable, and only the selected year is shown due to the\n\\texttt{showSelected=year} aesthetic. Finally, note that since the\nlabel \\texttt{x} and \\texttt{y} positions are constant, they are not\ndefined as aesthetics.\n\n%% As the pairing of text geom with a corresponding \\mbox{showSelected}\n%% aesthetic is frequently useful in linked plots, animint also includes\n%% a shorthand function to make defining this combination more efficient.\n\n%% <<yearText-make>>=\n%% yearText <- make_text(data=years, \n%%   x=5, y=80, showSelected=\"year\")\n%% @ \n\nWe can also add another label to show the selected country:\n\n<<countryText>>=\ncountryText <- geom_text(\n    aes(x=fertility.rate, y=life.expectancy, \n        label=country,\n        showSelected=country, \n        showSelected2=year),\n    data=WorldBank)\n@ \n\nNote that Animint allows any number of \\mbox{showSelected}\naesthetics. In this example, \\texttt{showSelected=country} combined\nwith \\texttt{showSelected2=year} means to only show the subset of\nlabels corresponding to both the selected year and country.  Since\nthere is only 1 row for each (country,year) combination in the\nWorldBank data, this has the effect of drawing the selected country's\nlabel at the location of the selected year.\n\nHaving defined these 3 geometric elements, we combine them in a single\nggplot:\n\n<<scatterPlot>>=\nscatterPlot <- ggplot()+\n  countryPoints+\n  yearText+\n  countryText\n@ \n\nThis completes the definition of the scatterplot. Now, we discuss the\ntime series on the left of Figure~1. First, the tallrects in the\nbackground are used to select the year:\n\n<<yearRects-geom>>=\nyearRects <- geom_tallrect(\n  aes(xmin=year-1/2, xmax=year+1/2, \n      clickSelects=year),\n  data=years, alpha=1/2)\n@ \n\n%Animint is designed for\n%interactivity via direct manipulation of the plot elements. \n%To facilitate this goal, \nThe tallrect is an Animint extension useful for selecting the variable\nwhich is plotted on the x axis, such as \\texttt{year} in this\nexample. The tallrect plots a rectangle for every row of the\n\\texttt{years} data table. The rectangle spans the entire y region,\nand the \\texttt{xmin} and \\texttt{xmax} aesthetics define the left and\nright limits. Since the designer specified \\texttt{clickSelects=year},\nusers can click on a tallrect to select a year. \n%% Finally,\n%% \\texttt{alpha=1/2} specifies that the selected tallrect should have an\n%% opacity of 50\\%. Since color is black by default, this results in a\n%% selected semi-transparent tallrect which appears grey. Since\n%% non-selected \\texttt{clickSelects} plot elements have 1/2 less opacity\n%% by default, this results in non-selected rectangles which are\n%% completely transparent, blending in with the white background.\n\n\n%% Animint also provides a shorthand syntax for tallrects, as they are a\n%% common geom/aesthetic pairing in linked plots.\n\n%% <<yearRects-make>>=\n%% yearRects <- make_tallrect(WorldBank, \"year\")\n%% @ \n\n%% This approach allows us to utilize both plots to display meaningful\n%% information: we can overlay the tallrects in the first plot with time\n%% series data while still using the tallrects to modify the second\n%% plot. Similar linked graphs could be produced with D3, but the grammar\n%% of graphics approach allows for fewer lines of code and simpler\n%% debugging.\n\nTo create the time series plot, we combine the tallrects above with\nlines. To declare that clicking a line should change the selected\ncountry, we use the \\texttt{clickSelects=country} aesthetic:\n\n<<timeSeries, tidy=FALSE>>=\ntimeSeries <- ggplot()+\n  yearRects+\n  geom_line(\n    aes(x=year, y=life.expectancy, \n        group=country, color=region,\n        clickSelects=country),\n    data=WorldBank, size=3, alpha=3/5)\n@ \n\nNote that both the \\texttt{timeSeries} and \\texttt{scatterPlot}\nobjects are valid ggplots. However, plotting them using the standard\nggplot2 library will show a non-interactive plot will all\ngeometric elements, including data for all years and countries. To\nplot them with Animint, we define a list of ggplots and options, then\ncall the \\texttt{animint2dir} compiler:\n\n<<animint2dir,fig.pos='htbp'>>=\nviz <- \n  list(scatterPlot=scatterPlot,\n       timeSeries=timeSeries,\n       time=list(variable=\"year\", ms=3000),\n       duration=list(year=1000))\nanimint2dir(viz, out.dir=\"WorldBank\")\n@ \n\nThe \\texttt{time} option specifies that in absence of user\ninteraction, we want the plots to animate over time, progressing at a\nrate of one year every 3 seconds. We also use the \\texttt{duration}\noption to specify a smooth transition over 1 second for the year\nvariable. The \\texttt{animint2dir} compiler saves some data files and a\nweb page in the \\texttt{WorldBank} directory, then it opens the\ninteractive plot in a web browser.\n\n\\subsection{User interaction}\n\n\\citet{instrumental-interaction} discussed the advantages of direct\nmanipulation in graphical user interfaces, and our Animint system\nfollows principle 2 ``Physical actions on objects vs. complex syntax''\nsuch as dialog boxes. In particular, the user can update the selection\nby clicking on the data objects themselves. This contrasts other\nsystems which use menus and widgets, and thus suffer from less\narticulatory directness \\citep{Hutchins:1985}.\n\nFor single selection variables such as year, clicking sets the value\nof the corresponding selection variable. For multiple selection\nvariables such as country, clicking adds or removes values from the\nset of selected values.\n\n\n\\subsection{Implementation details}\n\\label{sec:implementation}\n\nAs shown in Figure~\\ref{fig:design}, the Animint system is implemented\nin 2 parts: the compiler and the renderer.\n\n\\begin{figure}[b!]\n  \\centering\n  \\includegraphics[width=\\columnwidth]{figure-design}\n  \\caption{Schematic explanation of compilation and rendering the\n    World Bank visualization shown in Figure~1. \\textbf{Top}: the\n    interactive animation is a list of 4 R objects: 2 ggplots and 2\n    option lists. \\textbf{Center}: Animint R code compiles data in\n    ggplot geoms to a database of TSV files\n    (\\textcolor{red}{$\\rightarrowtriangle$}). It also compiles plot\n    meta-data including ggplot aesthetics, animation time\n    options, and transition duration options to a JSON meta-data file\n    ($\\rightarrowtriangle$). \\textbf{Bottom}: those data-dependent\n    compiled files are combined with data-independent JavaScript and\n    HTML files which render the interactive animation in a web browser\n    (\\textcolor{blue}{$\\rightarrowtriangle$}).}\n  \\label{fig:design}\n\\end{figure}\n\nThe compiler is implemented in about 1500 lines of R code that\nconverts a list of ggplots and options to a tab-separated values\n(TSV) file database and a JSON plot meta-data file. The compiler scans\nthe aesthetics in all of the ggplots to determine how many selection\nvariables are present, and which plots to update after a selection\nvariable is clicked. It uses ggplot2 to automatically calculate\nthe axes scales, legends, and labels. It outputs this information to\nthe JSON plot meta-data file. It also uses ggplot2 to convert data\nvariables (e.g. life expectancy and region) to visual properties\n(e.g. y position and color). The data are separated into several TSV\nfiles, so for large data sets the web browser only needs to download\nthe subset of data required to render the current selection\n\\citep{2013-immens}. Finally, the rendering engine\n(\\texttt{index.html}, \\texttt{d3.v3.js}, and \\texttt{animint.js}\nfiles) is copied to the plot directory. Since the compiled plot is\njust a directory of files, the designer can easily upload interactive\nplots to the web for sharing with users.\n\nThe \\texttt{animint.js} renderer is implemented in about 1500 lines of\nJavaScript/D3 code that renders the TSV and JSON plot data files as\nSVG in a web browser. \n%% The main idea for implementing interactivity is\n%% that clicking a \\texttt{clickSelects=year} geom calls the\n%% \\verb|update_selector| function, which stores the newly selected value\n%% of year, then calls \\verb|update_geom| to redraw every geom with\n%% \\texttt{clickSelects=year} or \\texttt{showSelected=year}. \nImportantly, animation is achieved by using the JavaScript\n\\texttt{setInterval} function, which updates the \\texttt{time}\nselection variable every few seconds.\n  \n\\section{Results and comparison study on World Bank data}\n\\label{sec:compare}\n\nTo show the advantages that the Animint grammar brings for creating\ninteractive and animated data visualizations, we implemented the World\nBank visualization of Figure~1 using two other R packages and Tableau\n(Table~\\ref{tab:packages}). The main result of our comparison is that\nAnimint requires significantly fewer lines of code, and produces\ninteractive plots with more articulatory directness\n\\citep{Hutchins:1985}. Note that is it possible to implement the World\nBank visualization in pure D3 (Figure~\\ref{fig:code}), but would\nrequire significantly more code.\n\n\\subsection{R package animation}\n\\label{sec:compare-animation}\n\nWe designed a version of the WorldBank visualization with limited\ninteractivity, using 38 lines of R code and the \\texttt{animation}\npackage (\\url{http://bit.ly/1hnUnkE}). The main idea behind this\napproach is to use an imperative programming style with for loops to\ncreate a static PNG image for each year of the data, and then show\nthese images in sequence. The main drawback to this approach is that\nthe resulting plot is only interactive with respect to the year\nvariable. In other words, the designer must select some countries to\nemphasize, and the user can not change that selection. Another\ndrawback is that R package \\texttt{animation} does not support smooth\ntransitions between animation frames. In contrast, using only 20 lines\nof the Animint DSL, the Animint package achieves smooth transitions\nand interaction with respect to both year and country variables.\n\n\\begin{table}[t!]\n%% Table captions on top in journal version\n  \\caption{Implementation complexity and features \n    of the World Bank data visualization\n    %of Figure~1 \n    using several libraries that can create interactive animations.\n    For each library\n    we show the number of lines of code (LOC), the on-screen objects \n    that can be clicked,  the\n    number of interaction variables, and URL of the interactive version. \n%  Note that different countries can not be interactively selected using\n% the visualization created with R package animation.\n  }\n \\label{tab:packages}\n \\scriptsize\n \\begin{center}\n  \\begin{tabular}{cccccc}\n    library & \n    LOC &\n    click on &\n    %language &\n    %years & \n    interaction vars &\n    http://bit.ly/\n    \\\\\n    \\hline\n    animint & \n    20 &\n    plotted data & \n    %R &\n    %2013- & \n    several & \n      \\bitly{worldBank}\n    \\\\\n    animation & \n    38 &\n    play/pause &\n    %R  &\n    %2007- & \n    1 = time & \n    \\bitly{1hnUnkE}\n    \\\\\n    %% D3 & \n    %% TODO &\n    %% JavaScript & \n    %% %2011- & \n    %% several & \n    %% %declarative & \n    %% \\\\\n    ggvis/shiny & \n    84 &\n    widgets & \n    %R  &\n    %2012- & \n    several & \n    \\bitly{1diUYsg}\n    \\\\\n    Tableau &\n      &\n    widgets/plot &\n    several &\n    \\bitly{worldBank-tableau}\n    \\\\\n  \\end{tabular}\n \\end{center}\n\\end{table}\n\n\\subsection{Client-server systems like ggvis/shiny}\n\nWe designed another version of the World Bank data visualization in 84\nlines of R code (\\url{http://bit.ly/1diUYsg}), using the ggvis\ngraphics library combined with the recommended shiny web server\npackage \\citep{shiny, ggvis}. Showing and hiding data subsets was\naccomplished by clicking on a slider for year and a menu for country,\nnot by clicking on the plot elements. In contrast, we designed\nFigure~1 using only 20 lines of R code with the Animint package. The\nreason why the implementation is significantly simpler using Animint\nis because its DSL is designed specifically for this type of\ninteractive animation.\n%Although creating such visualizations in ggvis+shiny is\n%possible, it requires significantly more work for limited\n%interactivity.\n\nAnother difference is the amount of work required to deploy or share a\nvisualization. A compiled Animint visualization consists of static\nTSV, JSON, HTML, and JavaScript files which can be easily served with\nany web server. In contrast, ggvis+shiny requires a web server with R \nand special software installed, significantly complicating \ndeployment to the web.\n\nThere are also inherent speed tradeoffs to using a client-server\nplotting system like ggvis+shiny rather than an entirely web\nclient/JavaScript-based system like Animint. There is one main\ndifference between these two types of systems that affects\nresponsiveness of a web-based interactive plotting system:\nclient-server communication overhead. All the \\mbox{Animint}\nJavaScript plot rendering code is executed in the web browser, whereas\nggvis executes some computations on the server. This means that after\na mouse click, ggvis can not update a plot immediately, but instead\nmust wait for the server to respond with the plot data.\n\nWe quantified speed differences between the two systems by timing web\npage loading using DevTools in the Chromium web browser Version\n33.0.1750.152 Ubuntu 12.04 (256984). We also used \\texttt{getTime()}\nin JavaScript to record timings for interactive plot updates (on a\ndesktop computer with a 2.8GHz Intel Core i7 CPU). Using ggvis with a\nlocal web server and the World Bank data resulted in a web page that\nloaded quickly (about 1.4s), but updated the plot with a noticeable\nlag after each mouse click (500--1000ms). Note that since we used a\nlocal web server, these times represent the overhead of the web server\nsystem, and would be larger with a remote web server.\n\n\\begin{table*}[b!]\n  \\centering\n  \\input{table-examples}\n  \\vskip 0.2cm\n  \\caption{Characteristics of eleven interactive visualizations designed with \n    Animint. From left to right, we show the data set name, the \n    lines of R code including data processing but not including comments\n    (80 characters max per line), \n    the amount of time it takes to compile the visualization (seconds), \n    the total size of the uncompressed TSV files in megabytes (MB),\n    the total number of data points (rows), \n    the median number of data points shown at once (onscreen),\n    the number of data columns visualized (variables), \n    the number of clickSelects/showSelected variables (interactive),\n    the number of linked panels (plots),\n    if the plot is animated, \n    and the corresponding Figure number in this paper (Fig).\n  }\n\\label{tab:examples}\n\\end{table*}\n\nWhen we used Animint to make the World Bank data visualization, the\ncompilation from R objects to 2.1MB of uncompressed TSV data files\ntook 2.3s. Using a local web server, the Animint JavaScript rendered\nthe plot very quickly (100--200ms). We also observed very fast plot\nupdates after mouse clicks in Animint: 20--30ms response times for\nselecting the year, and 60--70ms response times for selecting the\ncountry. \n%Furthermore, in web server systems the client may not cache\n%previously viewed subsets, which results in calculations inefficiently\n%being performed several times rather than simply saved for quick\n%viewing later. \n\nThe conclusion of our speed comparison is that the overhead of\ncommunicating with a web server results in significant slowdowns for\ninteractive animations. It is clear that for quick response times, it\nis preferable to use an entirely JavaScript-based system like\nAnimint.\n\nIn contrast, a web server system like ggvis+shiny would be more\nappropriate for\n%  interactive animations that have many more subsets of\n% the data than can ever be transferred over the network. In that case,\n% the web server will initially send only the first data subset, and\n% then send only the subsets of data that the client requests. However,\n% since the data sets we examined were not too large\n% (Table~\\ref{tab:examples}), client-side rendering using Animint\n% resulted in quick, responsive interactive animations.\n% Another application for which a web server system like ggvis+shiny\n% would be preferable is for \nperforming arbitrary calculations in R/C code on the server, in\nresponse to user inputs, and then sending the result across the\nnetwork for plotting in the user's web browser. This power is not\nalways necessary for interactive animations, since the only operation\nneeded is showing precomputed data subsets. However, the web server\nsystem would certainly be preferable when there are many more data\nsubsets than could ever be precomputed. In that case, the web server\nwould only compute the subsets that the user interactively specifies.\n\n\\section{Example applications}\n\nIn this section we discuss the range of examples that we have designed\nwith Animint. Table~\\ref{tab:examples} shows several characteristics\nof eleven interactive visualizations that we have designed using\nAnimint.\n\nWe quantified the implementation difficulty of the Animint examples\nusing lines of R code, including data processing but not including\ncomments (80 characters max per line). We counted the number of plots\nand variables shown to quantify the amount of information conveyed by\nthe visualization. Using only 17 lines of code, we designed a simple\nvisualization that shows 2 linked plots of 4 variables in the worldPop\ndata set. In contrast, the most complex visualization required 229\nlines of code, and it shows 44 variables across 5 linked plots\n(Figure~\\ref{fig:ChIPseq}). All of the visualizations that we designed\ninvolved at least 2 interaction variables (e.g. year and country in\nFigure~1) and 2 plots. Indeed, Animint is most appropriate for\ninteractive visualizations of multi-variate data that are not easy to\nview all at once in one plot.\n\nTable~\\ref{tab:examples} also shows Animint system requirements for\nplots of various sizes. We timed the compilation step in R code\n(``seconds'' column), and measured the size in megabytes of the\ncompiled TSV file database (``MB'' column), and found that both\nincrease with the data set size (``rows'' column). \n%Although we do not present timings for the rendering step, \nWe also noticed that the time required for the interactive updates and\nrendering increases with the amount of data displayed at once\n(``onscreen'' column). In particular, the climate data visualization\nhas noticeably slow animations, since it displays about 88980\ngeometric elements at once (\\url{http://bit.ly/QcUrhn}). We observed\nthis slowdown across all browsers, which suggested that there is an\ninherent bottleneck when rendering large interactive plots in web\nbrowsers using JavaScript and SVG. Another Animint with a similar\namount of total rows is based on the evolution data\n(\\url{http://bit.ly/O0VTS4}), but since it shows less data onscreen\n(about 2703 elements), it exhibits faster responses to interactivity\nand animation.\n\n\\subsection{Animated examples}\n\nAnimation is useful mainly for data sets which have a time variable,\nas in the World Bank data of Figure~1. \n\nFigure~\\ref{fig:tornado} shows an interactive animation of tornadoes\nobserved in the United States between 1950 and 2012. At any moment in\ntime, the user can simultaneously view the spatial distribution of\ntornadoes in the selected year over all states, and see the trend over\nall years for the selected state. Clicking a state on the map updates the\ntime series bars to show the tornado counts from that state. Clicking\na bar on the time series updates the selected year.\n\nFigure~\\ref{fig:climate} shows an interactive animation of climate\ntime series data observed in Central America. Two maps display the\nspatial distribution of two temperature variables, which are shown\nover time in corresponding the time series plots below. Scatterplots\nalso show the relationships between the two temperature variables, for\nthe selected time and region. Clicking any of the plots updates all 6\nof them. The \\texttt{clickSelects} and \\texttt{showSelected} aesthetics make it easy to\ndesign this set of 6 linked plots in only 87 lines of code. \n%% Animint's\n%% DSL allows for this level of flexibility while using minimal lines of\n%% code to define the plots and the relationship between them.\n\n\\subsection{Non-animated examples}\n\nWhen the data to visualize do not contain a time variable, we have\nfound that Animint is still useful for creating interactive but\nnon-animated plots. In fact, seven of the eleven examples in\nTable~\\ref{tab:examples} are not animated. For example, these plots\nare useful to illustrate complex concepts such as a change point\ndetection model in the breakpoints data\n(\\url{http://bit.ly/1gGYFIV}). The user can explore different model\nparameters and data sets since these are encoded as Animint\ninteraction variables.\n\nAnother non-animated example is Figure~\\ref{fig:ChIPseq}, which was\nused to explain a complex machine learning model for predicting\ndifferences between samples. The interactive visualization allows the\nuser to explore how the predictions change as a function of the model\ncomplexity parameter, in several train and test samples. It also uses\nfacets, a feature from ggplot2 that allows multi-panel plots with\naligned axes. Finally, it includes hyperlinks which open related web\npages in new windows.\n\nOverall, we have found that Animint is useful for exploring\nrelationships in many different kinds of multivariate data. By using\n\\texttt{clickSelects} and \\texttt{showSelected}, it is easy to design\ninteractive plots that reveal patterns in complex data.\n\n\\section{User feedback and observations}\n\nBy working with researchers in several fields of research,\nwe have created a wide variety of\ninteractive visualizations using Animint.\nTypically, the researchers have a complex data set that\nthey wish to visualize,\nbut they do not have the expertise or time to create\nan interactive data visualization.\nThe Animint DSL made it easy to collaborate with the various domain experts,\nwho were able to provide us with annotated sketches of the desired plots,\nwhich we then translated to Animint R code.\nIn this section we share comments and\nconstructive criticism that we have obtained from our users.\n\nR users have found that Animint is easy to learn. One statistics\nPh.D. student writes, ``animint is a fantastic framework for creating\ninteractive graphics for someone familiar with R and ggplot2's grammar\nof graphics implementation. The API is very intuitive and allows one\nto quickly bring their static graphics to life in a way that\nfacilitates exploratory data analysis.''\n\nFor the \\texttt{prior} data visualization\n(\\url{http://bit.ly/1peIT7t}), the Animint user is a machine learning\nresearcher who developed an algorithm and applied it to 4 benchmark\ndata sets. He wanted to explore how his algorithm performed, in\ncomparison to a baseline learning algorithm. He appreciated the\nintuition about his algorithm's performance that he learned from the\ninteractive plots: ``Interactive plotting allows us to explore all\nrelationships of our high-dimensional dataset and gives us an\nintuitive understanding of the performance of our proposed\nalgorithm. An intuitive understanding of the results is important\nsince it shows under which conditions our proposed method works well\nand provides avenues for further research.''\n\n\nAnother user from a machine learning background found the interactive\nplots useful for presenting his work: ``the `regularization path' is a\ndifficult concept to demonstrate in my research. The [Animint\n\\url{http://bit.ly/1gVb8To}] helped greatly by rendering an\ninteractive plot of regularization path, likelihood, and graph at the\nsame time and illustrating their connections. It also reveals an\ninteresting phenomenon that maximizing the testing likelihood actually\ngives many false positives.''\n\nIn another application, the Animint user was a genomics researcher:\n``viewing and exploring my complex intestinal microbiome dataset in\n[Animint] allowed me to grasp the patterns and relationships between\nsamples at an almost intuitive level. The interactive aspect of it was\nvery helpful for browsing through the dataset.''\n\nFinally, users also appreciated the simple web interface, and the\ndetail that is possible to show in interactive plots, but impossible\nto show in publications: ``...  the web interface is simple and easy\nto use.  It also enables us to publish more detailed interactive\nresults on our website to accompany the results presented in\npublications.''\n\n\\section{Discussion, limitations and future work}\n\nThere are several limitations to the current implementation of\nAnimint, which suggest avenues for future work.\n\nAnimint implements several linked plots, one of the hallmarks of\ninteractive visual analysis \\citep{iva}. However, one limitation to\nthe current implementation is that a selection is defined as a set of\ndistinct elements (e.g. year=\\{1991, 1992\\}) rather than a logical\nexpression (e.g. year $>1990$). Also, Animint does not yet\nimplement a rectangular brush for specifying values of \nmultiple selection variables. \nImportantly, these are drawbacks of the\ncurrent implementation, not the Animint DSL. \n\nAnother limitation of the current implementation is that axes and\nlegends are computed only once during the compilation step, and for\nsome plots it would be preferable to recompute the scales when the\nselection changes. Thus it is difficult to use interactivity to\nvisualize different data subsets which have very different ranges of\nvalues. For example, it would be awkward to use interactivity to show\ndifferent panels of a scatter plot matrix of several variables. A\nworkaround is shown in Figure~\\ref{fig:ChIPseq}, which omits the x\naxis on the bottom plot, since in fact the x values are all normalized\nto [0,1]. A future implementation of Animint would benefit from scales\nthat can be updated after each click.\n\n% Carson: this next part is no longer a serious drawback, right?\n% https://cpsievert.shinyapps.io/animintRmarkdown\n\n% Currently, the user who interacts with a rendered plot \n% is unable to change variable mappings, since these\n% are specified by the designer at compile time. A better interactive\n% system would allow the user to interactively change variable mappings.\n\nSince Animint does not perform any computations other than showing and\nhiding data subsets, there is a limitation to what can be\ndisplayed with multiple selection variables. \nThe limitation is that it is not feasible to precompute \nsomething to display for each of the combinatorial number of\npossible selections\nof a multiple selection variable.\nFor instance, in the\nWorldBank visualization of Figure~1, it would not be feasible to\ndisplay a single smoothing line computed from all the selected\ncountries. This is because \\texttt{showSelected=country} means to show\none thing for each selected country (not one thing computed based on\nthe set of selected countries). Supporting this kind of interaction\nwould require substantial modifications to the Animint system,\nincluding adding the ability to perform computations on\nmultiple selection variable sets.\n\nAs discussed in Section~\\ref{sec:design} and illustrated in\nFigure~\\ref{fig:design}, the compiler is written in R, and the\nrenderer is written in JavaScript. \n%% This means that Animint developers\n%% must be proficient in both R and JavaScript. This represents a\n%% significant barrier for source code contributions from developers who\n%% are proficient with one language but not the other.\nAnimint designers define interactive animations using only R code, and no\nknowledge of JavaScript is necessary. This is convenient for useRs\nfrom a statistical background, but presents a barrier for web\ndevelopers who are more familiar with JavaScript than R. For these web\ndevelopers, it would be advantageous in the future to implement a\ncompiler and renderer in pure JavaScript, by\npossibly building \\texttt{clickSelects} and \\texttt{showSelected} extensions into Vega\n\\citep{vega}.\n\nThe current Animint implementation is limited to two specific types of\ninteractivity: highlighting the selected \\texttt{clickSelects}\nelement, and showing/hiding \\texttt{showSelected} elements. In the\nfuture, we could implement several other types of interactivity\nwithout changing the Animint DSL. Examples include zooming,\npanning, and plot resizing. However, some\nkinds of interactivity would require extensions to the Animint\ngrammar. For example, a \\texttt{hoverSelects} aesthetic \ncould be used to change the selection when hovering over a data point.\n\nAnimint's performance can be measured using speed, memory, and disk\nspace requirements in the compilation and rendering steps. Although we\nshowed in Section~\\ref{sec:compare} that Animint provides smoother\ninteractivity than client-server systems, future versions of Animint\ncould be made even more efficient and responsive. For\nexample, of the plots in\nTable~\\ref{tab:examples}, the longest compilation step took 56.3 seconds,\nwhich may be reduced by optimizing the R code compiler.\n\nThis highlights one of the main motivations for using a declarative\nDSL like Animint: none of the designer's R code needs to be changed to\nimplement improvements like this. Instead, the Animint developers just\nneed to work on a better compiler and rendering engine. Indeed,\n\\citet{declarative} noted that this is one of the main benefits of\ndeclarative language design: ``By decoupling specification from\nimplementation, developers can implement language optimizations\nwithout interfering with the work of designers.'' \n\nWhile several\noptimizations remain to be implemented, the current Animint library\nalready provides an efficient syntax for the design of interactive,\nanimated data visualizations.\n\n\\section*{Acknowledgements}\n\nThe authors wish to thank Animint users MC Du Plessis, Song Liu,\nNikoleta Juretic, and Eric Audemard\nwho have contributed constructive criticism and helped its development.  \n\n% TDH 13 March 2014 This was in the template.tex file.\n%\\bibliographystyle{abbrv}\n\n\\bibliographystyle{abbrvnat}\n\n%%use following if all content of bibtex file should be shown\n%\\nocite{*}\n\\bibliography{refs}\n\\end{document}\n",
    "created" : 1416356131770.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "499304719",
    "id" : "B5A4FB0F",
    "lastKnownWriteTime" : 1416378576,
    "path" : "~/Desktop/github/local/animint-paper/HOCKING-animint.Rnw",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "type" : "sweave"
}